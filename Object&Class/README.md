# 객체와 클래스
⭐️ ⭐️ ⭐️ ⭐️ ⭐️ ⭐️ 
## 객체의 기본 사용법
[기본 사용법](./objectBasic.js)
⚠️ **객체나 배열을 키값으로 사용시**
- 실제로 해당 객체나 배열의 내용이나 참조값이 키가 되는 것이 아니라
- [object object]이런식으로 들어가있음.
- 객체를 문자열로 치환해서 넣어버림

=> **배열, object는 key값으로 쓰지 말아야한다.**

**객체 : 프로퍼티 삭제도 가능하다**
- delete person1.age -> delete 연산으로 가능
- 함수 인자로 동적으로 설정도 가능. 

**ES6 추가 문법**
- 객체 선언 시 프로퍼티 키와 대입할 상수/변수명이 동일할 시 단축 표현
- ES6 부터는 `메서드의 정의가 약간 다르다`. 
- 이전에는 salutate: function(formal){ return formal?,,,:,,,} 식도 메서드였는데
- 이젠 salutate(formal){return formal?,,,:,,,,}식으로 해야한다. 
  > 메서드 정의 달라진 거 한 번 더 찾아보기. 잘 모르겠음. 

?? 개인적으로 JS에서 Object와 class의 차이를 잘 모르겠음. (C++의 Class - struct 정도의 차이라고 생각했는데)

⭐️ ⭐️ ⭐️ ⭐️ ⭐️ 
## 생성자 함수
[생성자 함수](./constructor.js)
- 일반적으로 `대문자`로 시작한다. < 보통 대문자로 시작하는건 생성자 함수다. 컨벤션 규칙에 적용시키자! ( 파스칼 케이스 )
- 생성자 함수로 만들어진 객체를 인스턴스 instance 라 부름
- this.~로 생성될 인스턴스의 프로퍼티들 정의
- 생성자 함수는 `new` 연산자와 함께 사용
- 암묵적으로 `this 반환`
  - 실제로 console.log()로 찍어보면 본인을 반환함.
- 생성자 함수에서는 `메서드 정의 불가` - 객체 리터럴과 클래스에서는 가능

- ⚠️ **new를 붙이지 않으면 undefined 반환**
- **function으로 선언된 함수는 기본적으로 생성자 함수의 기능을 갖으나, new를 사용하지 않으면 그냥 함수로 사용되고, new를 붙이면 생성자 함수로 사용됨**

=> 그럼,,,, **💡 "객체를 반환하는 함수랑은 뭐가 다르지??"**

**생성자 함수로 만들어진 객체**
- 프로토타입 `prototype` - 자바스크립트 객체지향의 중심
  - js에는 원래 class가 없고 prototype이었다. 최근에 class가 추가된 것이다. 
  - 왜? 다른 언어랑 통일하려고! 
- 타 언어의 클래스와는 다르며 사용하기에 따라 더 강력함
  - ⚠️ 사실 introduce와 introEng은 종류가 다름 (인스턴스 vs 프로토타입) < prototype에서 더 알아보기.
- 생성자함수명.prototype.함수명 = function(){return}을 통해서 다른 기능을 추가할 수 있다.-> 먼저 생성한 object들도 이 기능이 추가된다.! 개신기! << **new 생성자함수를 객체 반환 함수 대신 사용하는 이유.**

![생성자와 object 반환 함수 차이](./constructor.png)

**생성자 함수 자체의 프로퍼티와 함수**
- console.log(YalcoChicken.contact()); << 생성자 함수 자체에 추가.(함수도 변수다!)
- console.log(chain1.contact()); << chain1에만 추가
- 근데 그냥 .으로 프로퍼티 추가 하면(prototype 없이), 이미 만들어진 instance들에는 추가 안됨. 

 
**💡 new 생략 실수 방지하기**
 - function 생성자함수명( 인자 ){~~`, if(!new.target){return new 생성자함수명(인수)}} << 재귀로!! 방지 가능! 

## 클래스 (Class)
[class MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Classes)
[클래스](./class.js)
- JS는 prototype, 생성자를 사용했는데 타언어랑 통일해주려고 class로 눈속임 한거래   
  - 💡 Syntactic Sugar - 문법을 보다 읽기 쉽게 만드는 것
  - class로 눈속임 한 걸 Syntactic Sugar이라 함. 
- ⚠️ 그러나 클래스와 생성자 함수의 동작이 동일하지는 않음
  - 1. 클래스는 호이스팅 되지 않는다.
  - 2. 클래스는 new 없이 사용하면 오류가 난다 ( 생성자 함수는 오류 없이 undefined )
  - 3. 클래스는 `엄격 모드`를 사용한다. < 이후에 배움

**constructor 메서드**
- 인스턴스 생성시 인자를 받아 `프로퍼티를 초기화`함
- 클래스에 `하나만` 있을 수 있음 - 초과시 오류 발생
- 다른 메서드 이름을 쓸 수 없음
- `기본값` 사용 가능
- 필요없을 (인자가 없을 때 등) 시 생략 가능
- **⚠️ 값을 반환하지 말 것! 생성자 함수처럼 암묵적으로 this 반환**

![클래스와 생성자 함수에 넣은 함수 차이 차이](image.png)
**클래스의 메서드**
- 클래스는 함수가 prototype에 들어가 있음.
- 생성자 함수는 객체에 들어감.
  => 클래스는 매번 본사에서 받아서 쓰는 개념이다.

**필드 field**
- `constructor 밖에서 this.~ 없이` 인스턴스의 프로퍼티 정의
- 지원하지 않는 브라우저가 있어도 Barbel로 해결 가능.
  - Before) class 클래스명 { constructor(){ this.name=머머머~}}
  - After) class 클래스명{name=머머머; op=4; attack(enemy){enemy.hp -= this.op; this.hp+=this.op/4} }

**static 필드**
- class에서는 static으로 가능. << class 자체의 기능. 
- 인스턴스의 수와 관계없이 메모리 한 곳만 차지
- 인스턴스 없이 클래스 차원에서 호출
- 메모리 상에서, YalkoChicken이 있는 메모리에 정적으로 만들어 놓은 변수, 함수가 있고 다른 인스턴스들은 따로. 
![정적 변수와 아닌 것의 차이](image-1.png)
  => introduce 함수는 메서드이기 때문에 이 또한 `그 본체는 본사의 프로토타입 한 공간에 들어있다`. -> 프로토타입 섹션에서 자세히.
- ⚠️ 정적 메서드에서는 정적 필드만 사용 가능 
  - => static 메서드는 static 변수만 사용 가능하다는 것임. 

++ 💡 클래스는 함수 
  > tyepof로 찍어보면 function으로 나옴
  => 함수의 일급 객체 섹션에서, 함수도 다른 곳에 할당할 수 있는 일급 객체라고 했다.
  => 클래스 = 함수? 클래스도 할당 가능한 일급 객체란 소리.

**컴퓨터 프로그래밍 언어 디자인에서, 일급 객체(영어: first-class object)란 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체를 가리킨다. 보통 함수에 인자로 넘기기, 수정하기, 변수에 대입하기와 같은 연산을 지원할 때 일급 객체라고 한다.-wikipedia/일급객체